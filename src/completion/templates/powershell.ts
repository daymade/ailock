/**
 * Generate PowerShell completion script for ailock
 */
export function generatePowerShellCompletion(): string {
  return `# ailock PowerShell completion script
# Generated by: ailock completion powershell

Register-ArgumentCompleter -Native -CommandName 'ailock','aiunlock' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
    
    $commands = @{
        'init' = 'Initialize ailock configuration'
        'lock' = 'Lock files to prevent modifications'
        'unlock' = 'Unlock files to allow modifications'
        'status' = 'Show protection status'
        'status-interactive' = 'Interactive status dashboard'
        'list' = 'List protected files'
        'ls' = 'List protected files (alias)'
        'diagnose' = 'Diagnose file protection issues'
        'generate' = 'Generate CI/CD and container configs'
        'protect' = 'Complete file protection (lock + hooks)'
        'completion' = 'Generate shell completion script'
        'setup-completion' = 'Interactive completion setup'
        'help' = 'Show help information'
    }
    
    $commandOptions = @{
        'init' = @('--force', '--interactive', '--config-only')
        'lock' = @('--verbose', '--dry-run', '--no-gitignore')
        'unlock' = @('--verbose', '--dry-run', '--all', '--no-gitignore')
        'status' = @('--verbose', '--simple', '--json')
        'list' = @('--all', '--long', '--locked-only', '--unlocked-only', '--json')
        'ls' = @('--all', '--long', '--locked-only', '--unlocked-only', '--json')
        'diagnose' = @('--verbose')
        'generate' = @('github', 'gitlab', 'bitbucket', 'jenkins', 'circleci', 'docker', 'devcontainer')
        'completion' = @('bash', 'zsh', 'fish', 'powershell')
    }
    
    # Parse the command line
    $elements = $commandAst.CommandElements
    $command = $null
    $subcommand = $null
    
    if ($elements.Count -ge 2) {
        $command = $elements[1].Value
    }
    
    # Complete commands
    if ($elements.Count -eq 2) {
        $commands.Keys | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
            [System.Management.Automation.CompletionResult]::new($_, $_, 'Command', $commands[$_])
        }
        return
    }
    
    # Complete command options or arguments
    if ($command -and $commandOptions.ContainsKey($command)) {
        # Check if we're completing an option (starts with -)
        if ($wordToComplete -like '-*') {
            $commandOptions[$command] | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterName', $_)
            }
        }
        # Special handling for commands that take file arguments
        elseif ($command -in @('lock', 'unlock', 'diagnose')) {
            # Try to get file suggestions from completion helper
            try {
                $type = switch ($command) {
                    'lock' { 'unlocked-files' }
                    'unlock' { 'locked-files' }
                    default { 'files' }
                }
                
                $suggestions = & ailock completion-helper --type $type --partial $wordToComplete 2>$null
                if ($suggestions) {
                    $suggestions | ForEach-Object {
                        [System.Management.Automation.CompletionResult]::new($_, $_, 'ProviderItem', $_)
                    }
                    return
                }
            } catch {
                # Fall back to file system completion
            }
            
            # Default file system completion
            Get-ChildItem -Path "$wordToComplete*" -ErrorAction SilentlyContinue | ForEach-Object {
                $name = $_.Name
                if ($_.PSIsContainer) {
                    $name += [System.IO.Path]::DirectorySeparatorChar
                }
                [System.Management.Automation.CompletionResult]::new($name, $name, 'ProviderItem', $_.FullName)
            }
        }
        # Special handling for completion command
        elseif ($command -eq 'completion' -and $elements.Count -eq 3) {
            $commandOptions[$command] | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        }
        elseif ($command -eq 'completion' -and $elements.Count -eq 4) {
            @('--install-instructions') | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterName', $_)
            }
        }
        # Generate command template options
        elseif ($command -eq 'generate') {
            $commandOptions[$command] | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        }
    }
}

# Function to help with testing completion
function Test-AilockCompletion {
    param(
        [string]$Command = "ailock "
    )
    
    $results = TabExpansion2 -inputScript $Command -cursorColumn $Command.Length
    if ($results.CompletionMatches.Count -gt 0) {
        Write-Host "Completions for '$Command':" -ForegroundColor Cyan
        $results.CompletionMatches | ForEach-Object {
            Write-Host "  $($_.CompletionText)" -ForegroundColor Green
        }
    } else {
        Write-Host "No completions found for '$Command'" -ForegroundColor Yellow
    }
}

Write-Host "ailock PowerShell completion loaded successfully!" -ForegroundColor Green
Write-Host "Test with: Test-AilockCompletion 'ailock '" -ForegroundColor Gray
`;
}